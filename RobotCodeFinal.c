#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    IRsensor1,      sensorReflection)
#pragma config(Sensor, dgtl1,  StateLED,       sensorDigitalOut)
#pragma config(Sensor, dgtl2,  button1,        sensorTouch)
#pragma config(Sensor, dgtl3,  sonar,          sensorSONAR_cm)
#pragma config(Sensor, dgtl5,  limitLeft,      sensorTouch)
#pragma config(Sensor, dgtl6,  limitRight,     sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           motor1,        tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           motor3,        tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port3,           motor4,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          motor2,        tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//****** MILESTONE 4  *******
//******  GROUP 022   *******

//enum for robot_state
typedef enum T_State {
	START= 0,
	SCAN,
	STOP,
	MOVE,
	DROP,
	BACK,
	SIGNAL,
};

//declaration
const int light_threshold = 512;
bool collision();

// Perform processing of measurements.
// Should be called with rate of at least 20 Hertz for proper detection of puck.
bool monitorLight()
{
	// Static variables are a special class of variables that maintain
	// their values between subsequent calls to a function.  The intialization
	// values are only stored in the variables when the function is first called.
	// After that, the values that were in the variable at the end of the last time
	// the function is called will be stored in the variable when the function
	// execution is started.
	static int minLevelIR1 = 4096;	// Minimum light level seen by IR sensor 1
	static int maxLevelIR1 = 0;			// Maximum light level seen by IR sensor 1
	static int diffLevelIR1 = 0;		// Delta between maximum and minimum seen in last 0.1 seconds
	int lightLevel1 = SensorValue[IRsensor1];
	bool returnValue;
	// Check if 100 msecs have elapsed.
	if ( time1[T1] > 100 )  {
		// 100 msecs have elapsed.  Compute delta of light level.
		diffLevelIR1 = maxLevelIR1 - minLevelIR1;
		// Reset calculation for next 100 msecs.
		maxLevelIR1 = 0;
		minLevelIR1 = 4096;
		clearTimer(T1);
		} else {
		// Check for new minimum/maximum light levels.
		if ( lightLevel1 < minLevelIR1 ) {
			minLevelIR1 = lightLevel1;
			} else if ( lightLevel1 > maxLevelIR1 ) {
			maxLevelIR1 = lightLevel1;
		}
	}
	// Check if light level difference over threshold.
	if ( diffLevelIR1 > light_threshold ) {
		returnValue = true;
		} else {
		returnValue = false;
	}
	return(returnValue);
}

//to detect collision
bool collision(){
	return (SensorValue[limitLeft] || SensorValue[limitRight]);
}

//to stop the robot
void stop_robot(){
	motor[motor1] = 0;
	motor[motor2] = 0;
}

//cable mechanism
void cable(){
  clearTimer(T1);
  while (time1[T1] < 500){
  		motor[motor3] = -20;
  }
  //reset motor
 	motor[motor3] = 0;
 //cable mechanism in effect
	wait1Msec(3000);
	clearTimer(T1);

	//robot goes back
	 while (time1[T1] < 700)
	{
	 	motor[motor1] = -50;
	 	motor[motor2] =  50;
	}
	//reset motor
	motor[motor1] = 0;
	motor[motor2] = 0;
	clearTimer(T1);
	//pull back arm
  while (time1[T1] < 400)
  {
   		motor[motor3] = 40;
  }
  //reset motor to 0 to stop the movement
  motor[motor3] = 0;
}

//main function for Milestone 4
task main()
{

	//initialization
	T_State robot_state = START;
	bool beaconVisible = false;
	SensorValue[StateLED] = 0;
	SensorValue(button1) = false;

	while( true ) {

		// Update sensor values
		beaconVisible = monitorLight();
		switch(robot_state){

			case START:
					//robot scan for IR when button1 is pushed
					if(SensorValue(button1)){
							SensorValue(button1) = false;
							robot_state = SCAN;
					}
					else{
				  	robot_state = START;
				  }
			break;

			case SCAN:
					//robot moves towards the beacon if it detects the IR(beaconVisible = true)
					if ( beaconVisible ) {
						robot_state = MOVE;
					}
					//else continue rotating the robot
					else{
						motor[motor1] = 45;
						motor[motor2] = 45;
						robot_state = SCAN;
					}


			break;

			case MOVE:
					//move the robot forward till it reaches the beacon
					stop_robot();
					//robot goes straight towards the beacon
					while(SensorValue(sonar)> 17){
							motor[motor1] =  45;
							motor[motor2] = -45;
							//robot goes to scan state if it collides with wall
							if(collision()){
								clearTimer(T1);
								//robot goes back
  							while (time1[T1] < 400)
  							{
   								motor[motor1] = -45;
   								motor[motor2] =  45;
 								}
								robot_state = SCAN;
							}
					}

				  //robot stops after the distance between the robot and beacon is 17 cm
				  //to start the cable mechanism
				  stop_robot();
				  robot_state = DROP;
			break;

			case DROP:
					//cable mechnanism
			  	cable();
					//signal task completion
					robot_state = SIGNAL;
			break;

			case SIGNAL:
					//rotate flag 360 degree for signal completion
					wait1Msec(1500);
					clearTimer(T1);
					while (time1[T1] < 3000)
					{
		 				motor[motor4] = 127;
					}
					motor[motor4] = 0;
					clearTimer(T1);
					//robot state is START to run the next test
					robot_state = START;
			break;

			case STOP:
					motor[motor1] = 0;
					motor[motor2] = 0;
	    	break;

			default:
				// This should never happen.
				robot_state = STOP;

		} // switch( robot_state)

	}  // while(true)

}
